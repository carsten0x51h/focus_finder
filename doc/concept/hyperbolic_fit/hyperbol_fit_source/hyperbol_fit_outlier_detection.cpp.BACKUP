#include <iostream>
#include <array>
#include <vector>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <iterator>

#include <boost/geometry.hpp>
#include <boost/geometry/geometries/point_xy.hpp>

#include <gsl/gsl_multifit_nlin.h>


// Warning, C++11 only!
// Boost.Range doesn't like lambdas without this:
#define BOOST_RESULT_OF_USE_DECLTYPE

#include <boost/optional.hpp>
#include <boost/range/adaptor/filtered.hpp>
#include <boost/range/adaptor/transformed.hpp>
#include <boost/range/algorithm/generate.hpp> // only needed for filling the vector
#include <boost/range/algorithm/copy.hpp> // only needed for printing
#include <boost/range/adaptor/sliced.hpp>

#include <boost/range/algorithm.hpp> // TODO: Required?

using namespace std; // TODO: remove...

namespace bg = boost::geometry; // point

typedef bg::model::d2::point_xy<float> DataPointT;
typedef std::vector<DataPointT> DataPointContainerT;


/**********************************************************************
 * Helper classes
 **********************************************************************/

// struct DataPointT {
//   float x;
//   float y;
//   DataPointT(float inX = 0, float inY = 0) : x(inX), y(inY) {}
// };

//typedef vector<DataPointT> DataPointsT;
   

struct GslMultiFitDataT {
  float x;
  float y;
  float sigma;
  GslMultiFitDataT(float inX, float inY, float inSigma) : x(inX), y(inY), sigma(inSigma) { };
};
  
typedef std::vector<GslMultiFitDataT> GslMultiFitParmsT;


/**********************************************************************
 * Curve to fit to is supplied by traits.
 **********************************************************************/
template <class FitTraitsT, class DataPointContainerT>
class CurveFitTmplT {
public:
  typedef typename FitTraitsT::CurveParamsT CurveParamsT;
  typedef typename DataPointContainerT::const_iterator DataPointContainerConstIteratorT;
  typedef typename DataPointContainerT::value_type DataPointT;
  
  /**
   * See http://en.wikipedia.org/wiki/Approximation_error for expl. of rel and abs errors.
   *
   * returns 0 
   */
  static int
  fitGslLevenbergMarquart(const DataPointContainerT & inData, typename CurveParamsT::TypeT * outResults,
			  double inEpsAbs, double inEpsRel, size_t inNumMaxIter = 5000) {
    GslMultiFitParmsT gslMultiFitParms;
    gslMultiFitParms.reserve(inData.size());
    
    // Fill in the parameters
    for (DataPointContainerConstIteratorT it = inData.begin(); it != inData.end(); ++it) {
      gslMultiFitParms.push_back(GslMultiFitDataT(it->x(), it->y(), 0.1f));
    }
 
    // Fill in function info
    gsl_multifit_function_fdf f;
    f.f      = FitTraitsT::gslFx;
    f.df     = FitTraitsT::gslDfx;
    f.fdf    = FitTraitsT::gslFdfx;
    f.n      = inData.size();
    f.p      = FitTraitsT::CurveParamsT::_Count; // TODO: CurveParamsT::_Count should be sufficient...
    f.params = & gslMultiFitParms;
    
 
    gsl_vector * guess = gsl_vector_alloc(FitTraitsT::CurveParamsT::_Count);  // Allocate the guess vector
    
    FitTraitsT::makeGuess(gslMultiFitParms, guess);  // Make initial guesses - here we just set all parameters to 1.0
    
    // Create a Levenberg-Marquardt solver with n data points and m parameters
    gsl_multifit_fdfsolver * solver = gsl_multifit_fdfsolver_alloc(gsl_multifit_fdfsolver_lmsder,
								   inData.size(), FitTraitsT::CurveParamsT::_Count);
    gsl_multifit_fdfsolver_set(solver, & f, guess);  // Initialize the solver
    
    int status, i = 0;
    
    // Iterate to to find a result
    do {
      i++;
      status = gsl_multifit_fdfsolver_iterate(solver); // returns 0 in case of success
      if (status) {  break; }
      status = gsl_multifit_test_delta(solver->dx, solver->x, inEpsAbs, inEpsRel);
    } while (status == GSL_CONTINUE && i < inNumMaxIter);

    // Store the results to be returned to the user (copy from gsl_vector to result structure)
    for (size_t i = 0; i < FitTraitsT::CurveParamsT::_Count; ++i) {
      typename FitTraitsT::CurveParamsT::TypeE idx = static_cast<typename FitTraitsT::CurveParamsT::TypeE>(i);
      (*outResults)[idx] = gsl_vector_get(solver->x, idx);
    }
 
    // Free GSL memory
    gsl_multifit_fdfsolver_free(solver);
    gsl_vector_free(guess);
 
    return status;
  }
};


#include <algorithm> // For std::minmax_element
#include <tuple> // For std::tie
#include <vector> // For std::vector
#include <iterator> // For global begin() and end()

/**********************************************************************
 * Hyperbol fit traits
 **********************************************************************/
class HyperbolFitTraitsT {
private:
  
public:
  struct CurveParamsT {
    enum TypeE { A_IDX = 0, B_IDX, C_IDX, D_IDX, _Count };
    struct TypeT : public std::array<float, TypeE::_Count> {
      TypeT(const gsl_vector * inVec = 0) {
        for (size_t i = 0; i < TypeE::_Count; ++i) {
          TypeE idx = static_cast<TypeE>(i);
          (*this)[i] = (inVec ? gsl_vector_get(inVec, idx) : 0);
        }
      }
    };
    // TODO: Need to set default values...
  };
 
  /**
   * All parameters with good starting values - may be improved.
   *
   * minmax See https://stackoverflow.com/questions/16772477/how-to-get-min-or-max-element-in-a-vector-of-structures-in-c-based-on-some-fi
   */
  static void makeGuess(const GslMultiFitParmsT & inData, gsl_vector * guess) {
    // Find min HFD -> good start value for c
    GslMultiFitParmsT::const_iterator minEl, maxEl;
    std::tie(minEl, maxEl) = std::minmax_element(begin(inData), end(inData),
						 [] (GslMultiFitDataT const& s1, GslMultiFitDataT const& s2)
						 {
						   return s1.y < s2.y;
						 });
    
    gsl_vector_set(guess, CurveParamsT::A_IDX, 1.0);
    gsl_vector_set(guess, CurveParamsT::B_IDX, 2.0);
    gsl_vector_set(guess, CurveParamsT::C_IDX, minEl->x);
    gsl_vector_set(guess, CurveParamsT::D_IDX, 1.0);
  }

  /**
   * Phi() is a repeating part of the function calculation used by
   * different derivations.
   */
  static float phi(float x, float a, float c) {
    const float a2 = a * a;
    const float diff = x - c;
    const float diff2 = diff * diff;
    
    return sqrt(1.0 + (diff2 / a2));
  }
  
  /* H(x) */
  static float fx(float x, const CurveParamsT::TypeT & inParms) {
    const float a = inParms[CurveParamsT::A_IDX];
    const float b = inParms[CurveParamsT::B_IDX];
    const float c = inParms[CurveParamsT::C_IDX];
    const float d = inParms[CurveParamsT::D_IDX];
    
    return b * phi(x, a, c) + d;
  }
 
  /* Calculates H(x) for each data point. */
  static int gslFx(const gsl_vector * x, void * inGslParams, gsl_vector * outResultVec) {    
    // Store the current coefficient values
    CurveParamsT::TypeT curveParams(x);
    
    // Store parameter values
    const GslMultiFitParmsT * gslParams = ((GslMultiFitParmsT*) inGslParams); 
    // Execute Levenberg-Marquart on f(x)
    for(size_t i = 0; i < gslParams->size(); ++i) {
      const GslMultiFitDataT & gslData = gslParams->at(i);
      float yi = HyperbolFitTraitsT::fx((float) gslData.x, curveParams);

      // TODO: Is this ok?
      gsl_vector_set(outResultVec, i, (yi - gslData.y) / gslData.sigma);
    }
    
    return GSL_SUCCESS;
  }
 
  /* Calculates the Jacobian (derivative) matrix  */
  static int gslDfx(const gsl_vector * x, void * params, gsl_matrix * J) {
    // Store parameter values
    const GslMultiFitParmsT * gslParams = ((GslMultiFitParmsT*) params);
    
    // Store current coefficients
    float a = gsl_vector_get(x, CurveParamsT::A_IDX);
    float b = gsl_vector_get(x, CurveParamsT::B_IDX);
    float c = gsl_vector_get(x, CurveParamsT::C_IDX);
    
    // Store non-changing calculations
    const float a2 = a * a;
    const float a3 = a * a2;
    
    for(size_t i = 0; i < gslParams->size(); ++i) {
      const GslMultiFitDataT & gslData = gslParams->at(i);
      
      const float oneBySigma = 1.0f / gslData.sigma;
      const float x = gslData.x;
      const float x_minus_c = x - c;
      
      gsl_matrix_set(J, i, CurveParamsT::A_IDX, -oneBySigma * b * (x_minus_c * x_minus_c) / (a3 * phi(x, a, c)));
      gsl_matrix_set(J, i, CurveParamsT::B_IDX, oneBySigma * phi(x, a, c));
      gsl_matrix_set(J, i, CurveParamsT::C_IDX, -oneBySigma * b * x_minus_c / (a2 * phi(x, a, c)));
      gsl_matrix_set(J, i, CurveParamsT::D_IDX, oneBySigma);
    }
    
    return GSL_SUCCESS;
  }
  
  /* Invokes f(x) and f'(x) */
  static int gslFdfx(const gsl_vector * x, void * params, gsl_vector * f, gsl_matrix * J) {
    gslFx(x, params, f);
    gslDfx(x, params, J);
    
    return GSL_SUCCESS;
  }
};


/**********************************************************************
 * Calculation of asymptotes / slopes
 **********************************************************************/
float left_slope(float x, float a, float b, float c, float d) {
  return -(b/a) * (x-c) + d;
}
float right_slope(float x, float a, float b, float c, float d) {
  return (b/a) * (x-c) + d;
}




/**
 * See https://stackoverflow.com/questions/1719070/what-is-the-right-approach-when-using-stl-container-for-median-calculation/2579393#
 */
template<typename T> T
median(std::vector<T> & v) {  
  if(v.empty()) {
    return 0.0;
  }

  size_t numEntries = v.size();
  bool odd = numEntries % 2;
  
  auto n = v.size() / 2;
  std::nth_element(v.begin(), v.begin() + n, v.end());
  
  auto med = v[n];
  
  if(! odd) { //If the set size is even
    auto max_it = std::max_element(v.begin(), v.begin() + n);
    med = (*max_it + med) / 2.0;
  }
  
  return med;
}


typedef float (*model_function)(float);

/**
 * TODO: This function can probably be improved further by reducing copy... (-> fully lazy...)
 */


template<typename DataPointContainerT, typename ModelFunctionT> static int
detectAndRemoveOutliers(const DataPointContainerT & inData, ModelFunctionT pModelFunction, DataPointContainerT * outNoOutliersContainer, auto maxNumDataPointsToBeRemoved, auto fac = 2.5) {


  // TODO: Throw "custom" exception if fitting "failed"... include all required data into exception  - like outliers, abs and rel. error if available by gsl fitting call, number of iterations, "best" fit data points so far...
  
  //
  //filterOutlierTrans

  
  // Pick N first entries...
  
  //auto med = median(residuals); // NOTE: Currently modifies order of elements in container to avoid copying

  // TODO: Calc Q3?!?!? -> Q3 * fac. !!!
  
  //auto outlier_boundary = fac * med;

  //std::cout << "median=" << med << ", outlier_boundary: " << outlier_boundary << std::endl;

  //outlier_boundary
  //auto filterOutlierTrans = inData | filtered([&](typename DataPointContainerT::value_type p) { return (fabs(p.y() - pModelFunction(p.x())) < outlier_boundary && (--maxNumDataPointsToBeRemoved) > 0

													
     //												--> TODO: remove datapoints with biggest residual first!! -> need data structure which associates data-point with calculated residual... -> sort... -> map(residual -> DataPoint? -> use boost range to map the vector to a map??)); });

  // std::cout << "Without outliers:" << std::endl;
  // boost::range::for_each(filterOutlierTrans, [](typename DataPointContainerT::value_type p) {
  //     std::cout << "x=" << p.x() << ", y=" << p.y() << std::endl;
  //   });

  //const size_t numPoints = inData.size();
  
  // Copy result
  //outNoOutliersContainer->clear();
  //outNoOutliersContainer->reserve(numPoints);
  //boost::range::copy(filterOutlierTrans, std::back_inserter(*outNoOutliersContainer));

  //std::cout << "numPoints: " << numPoints << ", outNoOutliersContainer->size(): " << outNoOutliersContainer->size() << std::endl;

  //return (numPoints - outNoOutliersContainer->size()); // numOutliers
return 0; // HACK
}



/**********************************************************************
 * Custom data structure + accessor
 **********************************************************************/
// typedef pair<float, float> MyDataPointT;
// typedef vector<MyDataPointT> MyDataContainerT;
 
// class MyDataAccessorT {
// public:
//   typedef MyDataContainerT TypeT;
//   static DataPointT getDataPoint(size_t inIdx, TypeT::const_iterator inIt) {
//     DataPointT dp(inIt->first /*inIdx*/, inIt->second /*y*/);
//     return dp;
//   }
// };



typedef CurveFitTmplT<HyperbolFitTraitsT, DataPointContainerT> HyperbolMatcherT;
typedef HyperbolMatcherT::CurveParamsT VCurveParamsT;
typedef std::pair<float, typename DataPointContainerT::value_type> ResidualAndDataPointT;


/**
 *
 */
class FittingStatsT {
private:
  std::vector<ResidualAndDataPointT> outliers;
  VCurveParamsT::TypeT vCurveParms;
  
public:
  const std::vector<ResidualAndDataPointT> & getOutliers() { return outliers; }
  void setOutliers(const std::vector<ResidualAndDataPointT> & inOutliers) { outliers = inOutliers; }

  const VCurveParamsT::TypeT & getVCurveParms() const { return vCurveParms; }
  void setVCurveParms(const VCurveParamsT::TypeT & inVCurveParms) { vCurveParms = inVCurveParms; }
  
  // TODO...
};


/**
 *
 */
class VCurveFitExceptionT : public std::exception {
private:
  std::string description;
  FittingStatsT fittingStats;
  
public:
  VCurveFitExceptionT(const char * inDescription, const FittingStatsT & inFittingStats) : description(inDescription), fittingStats(inFittingStats) {};
  ~VCurveFitExceptionT() throw() {};
  const char *what() const throw() { return this->description.c_str(); };
  const FittingStatsT & getFittingStats() const { return fittingStats; };
};



/**
 *
 */
VCurveParamsT::TypeT fitVCurve(const DataPointContainerT & inDataPointsToFit, float inMaxAcceptedOutliersPerc = 20.0f, FittingStatsT * outFittingStats = nullptr) {
  
  using namespace boost::adaptors;

  VCurveParamsT::TypeT hyperbolCurveParms;

  size_t numIterations = 0;
  size_t numInitialDataPoints = inDataPointsToFit.size();
  size_t numMaxAcceptedOutliers = numInitialDataPoints * inMaxAcceptedOutliersPerc / 100.0f;
  size_t numMinRequiredDataPoints = numInitialDataPoints - numMaxAcceptedOutliers;
  size_t numCurrOutliers = 0;


  
  // Sort criteria: Smallest residual first, if residual equal, greatest y first (because data points further
  // outside V-Curve are potentially more important).
  auto less = [](const ResidualAndDataPointT & e1, const ResidualAndDataPointT & e2) -> bool {
    return ((fabs(e1.first - e2.first) > std::numeric_limits<float>::epsilon()) ? e1.first < e2.first : e1.second.y() > e2.second.y());
  };

  auto modelFunction = [&](float x) { return HyperbolFitTraitsT::fx(x, hyperbolCurveParms); };
  
  auto residualTrans = inDataPointsToFit | transformed([&](typename DataPointContainerT::value_type p) { return std::make_pair(fabs(p.y() - modelFunction(p.x())), p); });

  typedef std::multiset<ResidualAndDataPointT, decltype(less)> ResidualToDataPointsT;
  ResidualToDataPointsT residualToDataPoints(residualTrans.begin(), residualTrans.end(), less);

  // Initially copy data points to residualToDataPoints
  //boost::range::copy(inDataPointsToFit | residualTrans, std::inserter(residualToDataPoints, residualToDataPoints.begin()));

  
  std::cout << "numInitialDataPoints: " << numInitialDataPoints << ", maxAcceptedOutliersPerc: " << inMaxAcceptedOutliersPerc << "% -> numMinRequiredDataPoints: " << numMinRequiredDataPoints << std::endl;


  
  do {
    // Do the LM fit
    ++numIterations;
    
    // Return value of fitGslLevenbergMarquart() is not evaluated here...
    // TODO: Pass in range of residualToDataPoints... - lambda - access to second pair entry...
    int status = HyperbolMatcherT::fitGslLevenbergMarquart(inDataPointsToFit, & hyperbolCurveParms, 0.1f /*EpsAbs*/, 0.1f /*EpsRel*/);

    if (status) {
      std::cout << "GSL ERROR: " << gsl_strerror(status) << std::endl;
      // TODO: throw error...
    }
    
    // Extract residuals
    float residualLimit = 2.0; // TODO: Calc... 1.5 * Q3

    typename ResidualToDataPointsT::const_iterator itUp = std::upper_bound(residualToDataPoints.begin(),
									   residualToDataPoints.end(),
									   ResidualAndDataPointT(residualLimit, DataPointT()),
									   [](const ResidualAndDataPointT & lhs, const ResidualAndDataPointT & rhs) -> bool {
									     return lhs.first < rhs.first;
									   });
  
    size_t numValidDataPoints = std::distance(residualToDataPoints.begin(), itUp);
    numCurrOutliers = residualToDataPoints.size() - numValidDataPoints;

    std::cout << "numCurrOutliers: " << numCurrOutliers << std::endl;

  
    // TODO: Use copy_n instead of sliced() since sliced requires RandomAccessIterator...
    //size_t N = 1; // TODO...
    //auto filterOutlierTrans = residualTrans | sliced(0, 1);//filtered([&](const EntryT & e1) { return (e1.first < limit && (++maxNumRemove < 3) ); } );
    
    // TODO: UPDATE residualToDataPoints....
    
    
    // DEBUG output
    for (typename ResidualToDataPointsT::const_iterator it = residualToDataPoints.begin(); it != residualToDataPoints.end(); ++it) {
      std::cout << "Residual: " << it->first << ", dp(x,y)=(" << it->second.x() << ", " << it->second.y() << ")" << std::endl;
    }
    
    
  } while(numCurrOutliers > 0 && residualToDataPoints.size() >= numMinRequiredDataPoints);


  // TODO / IDEA: Lambda to fill FittingStatsT... - call from below...
  
  
  // Check if fitting was finally successful
  if (residualToDataPoints.size() < numMinRequiredDataPoints) {
    std::stringstream ss;
    ss << "Not enough data points with sufficient model accuracy. Require at least "
       << numMinRequiredDataPoints << " datapoints but only have "
       << residualToDataPoints.size() << " / " << numInitialDataPoints << "." << std::endl;

    FittingStatsT fittingStats;
    //fittingStats.setOutliers();
    fittingStats.setVCurveParms(hyperbolCurveParms);
    
    VCurveFitExceptionT exc(ss.str().c_str(), fittingStats); // TODO: ok? c_str(9 is tmp...?!
    throw exc;
  }


  if (outFittingStats != nullptr) {
    FittingStatsT & fs = *outFittingStats;
    //fs.setOutliers();
    fs.setVCurveParms(hyperbolCurveParms);
  }

  
  return hyperbolCurveParms;
}


/**********************************************************************
 * Main
 **********************************************************************/
int main(int argc,  char** argv) {

  // Check argument
  if (argc != 2) {
    std::cout << "Usage: hyperbol_fit <path/to/datafile>" << std::endl;
    return -1;
  }
  
  std::string filename(argv[1]);
  
  // Fill data container with some hyperbol shaped data
  DataPointContainerT dataPointsToFit;

  // Read data file
  std::ifstream infile(filename);
  float x, y;
  while (infile >> x >> y) {
    dataPointsToFit.push_back(DataPointT(x,y));
  }

  // Do the fit
  VCurveParamsT::TypeT vCurveParms;
  
  try {
    vCurveParms = fitVCurve(dataPointsToFit);
  } catch (VCurveFitExceptionT & exc) {
    // TODO:
    std::cerr << "V-Curve fitting failed..." << std::endl;
  }

  
  // Print calculated curve parameters
  std::cout << "a=" << vCurveParms[VCurveParamsT::A_IDX] << std::endl
	    << "b=" << vCurveParms[VCurveParamsT::B_IDX] << std::endl
	    << "c=" << vCurveParms[VCurveParamsT::C_IDX] << " (opt. position)" << std::endl
	    << "d=" << vCurveParms[VCurveParamsT::D_IDX] << std::endl;
  
  return 0;
}
